<html>

<head>
<meta charset="utf-8" />
<title>Cornell Software Map</title>
<link rel="stylesheet" href="leaflet/leaflet.css" />
<link rel="stylesheet" href="leaflet/awesomplete.css" />
<script src="leaflet/leaflet.js"></script>
<script src="leaflet/leaflet-omnivore.min.js"></script>
<script src="leaflet/leaflet-tilelayer-colorfilter.min.js"></script>
<script src="leaflet/awesomplete.min.js"></script>
<style>

body { font-family:"Segoe UI", Roboto, Arial, sans-serif }

h1 { margin:0 0 0.5em }
h1 a { text-decoration:none ; color:#b31b1b ! important }
h1 a:hover { color:#d31b1b ! important }

#search { width:25% ; float:left ; padding:0 1% }
#q { width:16em }
.awesomplete { z-index:99999 ; font-family: Arial ; font-size:80% }
.awesomplete > ul { transition:none ; background:rgba(255,255,255,1) }
.awesomplete input { width:20em }
.awesomplete mark { background:none ! important ; font-weight:bold }

#results a { text-decoration:none ; color:#b31b1b }
#results a:hover, #results a:focus { text-decoration:underline ; font-weight:bold }

#map { height:95% ; width:40% }

#info { width:31% ; padding:0 1% ; float:right }
#info > h2 { margin:0 ; background:#ff0 ; text-align:center }
#info th { width:6em ; text-align:right ; color:#aaa ; vertical-align:top ; padding:3px }
#info td { padding:3px }
#info ul { margin:0 ; padding:0 ; list-style-type:none }
#info ul li { margin:0 }


</style>
</head>

<body>
<div id='search'>
  <h1><a href='#' id='home'>Cornell Software Map</a></h1>
  <form id='searchform'>
    Search: for software at Cornell:<br>
    <input id='q' />
    <button type='submit'>search</button>
  </form>
  <ul id='results'></ul>
</div>
<div id='info'></div>
<div id='map'></div>
<script>

document.getElementById('home').onclick = home;
document.getElementById('searchform').onsubmit = submitSearch;
document.onkeyup = function(e) {
  if (e.key=='Escape') {
    clear_info();
  }
}

// fadeAnimation:false is recommended for grayscale tilelayer, otherwise it may flicker
var map = L.map('map', { fadeAnimation:false })
  //.on('click', function(e) { console.log(e.latlng); })
  .setMaxBounds([[42.4328,-76.4996], [42.4674,-76.4478]]);

// use a openstreetmap basemap
var osm = L.tileLayer.colorFilter('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  maxZoom: 19,
  minZoom: 14,
  opacity: 1,
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, <a href="https://carto.com/location-data-services/basemaps/">Carto</a>',
  filter: [
    'brightness:60%',
    'contrast:400%',
    'saturate:150%'
  ]
}).addTo(map);


var customLayer = L.geoJson(null, {
  // display as little circles
  pointToLayer: function(point, latlng) {
    return L.circleMarker(latlng);
  },
  style: function() {
    return {
      radius: 8,
      color: '#eee',
      fillColor: '#b31b1b',
      weight: 1,
      fillOpacity:1
    };
  },
  onEachFeature: function(feature, layer) {
    // calculate fulltext for searching
    var f = '';
    for (p in feature.properties) {
      f += ' ' + feature.properties[p];
    }
    feature.properties.fulltext = f;
    layer.bindTooltip(feature.properties.name, {direction:'right'});
    layer.on('click', function(e){ show_info(e.target); });
  }
});



var labs = omnivore.geojson('labs.geojson', null, customLayer)
  .on('ready', function() {
    // once we have all the data...
    initAutocomplete(this.getLayers());
    search(''); // interpretHash won't display points unless we start by searching for everything
    interpretHash();
  })
  .addTo(map);

console.log(labs);


function escapeRegExp(text) {
  return text.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}


function initAutocomplete(layers) {
  console.log('initAutocomplete...');
  // build a list of all software, and use it to provide
  // autocomplete for the search box
  var all_software = [];
  for (var j=0; j<layers.length; j++) {
    var software = layers[j].feature.properties.software;
    for (let i=0; i<software.length; i++) {
      var s = software[i];
      if (all_software.indexOf(s) < 0) {
        all_software.push(s);
      }
    }
  }
  // sort software by name, case-insensitive
  all_software.sort(function(a,b){
    var aa = a.toLowerCase();
    var bb = b.toLowerCase();
    if (aa<bb) return -1;
    if (aa>bb) return 1;
    return 0;
  });

  //console.log(all_software);
  // add the autocomplete to the search box
  var q = document.getElementById('q');
  new Awesomplete(q, {
    list: all_software,
    minChars: 1,
    filter: function (text, qterm) {
      var re = new RegExp('\\b' + escapeRegExp(qterm), 'i');
      return re.test(text);
    },
    autoFirst: false
  });
  // execute the search whenever the input changes
  q.addEventListener('awesomplete-selectcomplete', submitSearch);
  //q.oninput = search;
  //q.onkeyup = search; // just in case the browser doesn't support oninput
  q.focus();
  //interpretHash();
  //search();
}


function interpretHash() {
  // automatically search for terms in the URL hash,
  // so that links to specific searches or features can be shared by URL
  var hash = location.hash;

  // unescape hash
  hash = unescape(hash).replace(/\+/g, ' ');

  document.title += ': ' + hash;

  // escaped slashes are part of the query term, so don't split on double-slashes
  var params = hash.split(/(?<!\/)\/(?!\/)/);
  var q = params[1].replace('//', '/'); // convert escaped slashes back to single slashes
  var id = params[2];

  if (q === undefined) {
    q = '';
  }

  document.getElementById('q').value = q;
  document.getElementById('q').innerHTML = q;
  search(q, id);
}


function show_info(layer) {
  // return info HTML for the layer feature
  // TODO use mustache templates?
  clear_info();
  var p = layer.feature.properties;
  var html = '<h2>' + p.name + '</h2>';
  html += '<table>';
  for (var i in Object.keys(p)) {
    var property = Object.keys(p)[i];

    // don't show these fields
    if (['id','name','fulltext'].indexOf(property) > -1) {
      continue;
    }
    var value = p[property];

    // don't list null or blank properties
    if (value === null || value === '') {
      continue;
    }

    // linkify things that look like links
    if (typeof(value)=='string' && value.startsWith('http')) {
      value = value.replace(/(?!")(http\S+)/g, '<a href="$1">$1</a>');
    }

    // use html list for software values
    if (property=='software' && value.length>0) {
      value= '<ul><li>' + p.software.join('</li><li>') + '</li></ul>';
    }

    html += '<tr><th>'+property+':</th><td>' + value + '</td></tr>';
  }
  html += '</table>';
  document.getElementById('info').innerHTML = html;

  // highlight this marker
  layer.bringToFront().setStyle({fillColor:'#ff0', color:'#000', radius:12});
}


function clear_info() {
  document.getElementById('info').innerHTML = '';
  // reset all markers
  labs.eachLayer(function(el){
    labs.resetStyle(el);
  });
}

function encodeHash(h) {
  // escape slashes with // and keep + : =
  h = escape(h.replace(/\//g, '//'))
    .replace(/%20/g, '+')
    .replace(/%3A/g, ':')
    .replace(/%3D/g, '=');
  return h;
}

function home() {
  location.hash = '/';
  interpretHash();
}

function submitSearch(e) {
  e.preventDefault();
  e.returnValue = '';
  console.log('submitting search...');
  var q = document.getElementById('q').value.trim();
  location.hash = '/' + encodeHash(q);
  search(q);
  return false;
}

function search(q, showid) {
  // showid is optional, and will show details for that result
  console.log('searching for... ' + q);
  // note that query must match beginning of a word
  var re = new RegExp('\\b' + escapeRegExp(q), 'i');
  var layers = labs.getLayers();
  // sort by name
  layers.sort(function(a,b){
    var aa = a.feature.properties.name.toLowerCase();
    var bb = b.feature.properties.name.toLowerCase();
    if (aa<bb) return -1;
    if (aa>bb) return 1;
    return 0;
  });
  var results = document.getElementById('results');

  // reset results
  results.innerHTML = '';
  clear_info();

  var lastMatch = null;
  var bounds = L.latLngBounds();
  for (var i=0; i<layers.length; i++) {
    var item = layers[i];
    if (item.feature.properties.fulltext.match(re)) {
      lastMatch = item;
      item.addTo(map);

      var ll = item.getLatLng();
      if (ll.lat != 0 || ll.lng != 0) {
        // expand bounds to include current point
        bounds.extend(item.getLatLng());
      }

      var id = item.feature.properties.id;
      var name = item.feature.properties.name;
      var li = document.createElement('li');
      li.innerHTML = '<a href="#/' + encodeHash(q) + '/' + encodeHash(id) + '">'+name+'</a>';
      var a = li.firstChild;

      // link to marker on map
      a.setAttribute('data', i);
      a.onmouseover = function(e){
        var id = e.target.getAttribute('data');
        layers[id].openTooltip();
      }
      a.onmouseout = function(e){
        var id = e.target.getAttribute('data');
        layers[id].closeTooltip();
      }
      a.onclick = function(e){
        var id = e.target.getAttribute('data');

        var item = layers[id];
        show_info(item);

        var ll = item.getLatLng();
        if (ll.lat != 0 || ll.lng != 0) {
          map.panTo(ll);
        }
      }
      a.onfocus = function(e){
        e.target.click();
      }

      results.appendChild(li);
      if (id === showid) {
        a.focus();
      }
    }
    else {
      item.remove();
    }
  }
  // automatically show details if there is only one match
  if (results.childNodes.length == 1) {
    show_info(lastMatch);
  }

  // pad the bounds by 10% so that points aren't right on the edge of the map
  if (bounds.isValid()) {
    map.fitBounds(bounds.pad(0.03));
  }
}

</script>

</body>
</html>
